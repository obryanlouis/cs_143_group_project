// Router.cpp

#include "Router.h"
#include "Node.h"
#include "Packet.h"
#include "Control.h"
#include <iostream>

extern Controller *SYSTEM_CONTROLLER;

Router::Router(int id) { 
    // Make a new routing table
    this->routingTable_p = new RoutingTable();
    // Add an entry to the routing table saying that the distance to this router
    // is 0.
    (*this->routingTable_p)[this] = std::make_pair<int, Link*>(0, NULL);
    // Set the id of this router
    this->nodeId = id;
}

Router::Router(int in_id, std::list<Link*> l)
    : Node(in_id)
{
    this->links = l;
}

Router::~Router() {
    delete this->routingTable_p;
}

void Router::handlePacket(Packet *packet){
    Node::handlePacket(packet);
    std::cout << "Router id: "
              << this->nodeId
              << " is handling packet"
              << " at time "
              << SYSTEM_CONTROLLER->getCurrentTime()
              << "\n";
    assert(packet != NULL);

    bool  updated;   // to be used if the packet is for Routing Table Updates

    // Initialize variables to right type (must be done before switch table.)
    RouterRoutingPacket *R = (RouterRoutingPacket *) packet;
    AckPacket *A = (AckPacket *) packet;
    DataPacket *D = (DataPacket *)packet;
    HostRoutingPacket *H = (HostRoutingPacket *) packet;

    switch (packet->getType())
    {
    case Packet::HOSTROUTE:
        // the host is telling this router that it exists 
        this->updateSingleNode(H->getHost(), H->getLink());
        delete packet;
        break;
    case Packet::ROUTERROUTE:
        // handing routing table information
        updated = updateRoutingTable(R->getRoutingTable(), R->getLink());
        // If the routing table was updated, broadcast this to all
        // neighbors.
        if (updated) {
            this->broadcastRoutingTable();
        }

        delete packet;
        break;
    case Packet::ACK:
        // handle acknowledgement packets: same as data packets
    case Packet::DATA:
        // handle data packets
        (getNextLink(D->getDestination()))->handlePacket(packet);
        break;
    default:
        std::cout << "INVALID PACKET TYPE" << std::endl;
        assert(0);
        break;
    }
}

void Router::broadcastRoutingTable() {
    std::cout << "Router " << nodeId << " starting broadcasting routing table"
        << " at time " << SYSTEM_CONTROLLER->getCurrentTime() << "\n";
    for (std::list<Link* >::iterator it = this->links.begin();
            it != this->links.end(); it++)
    {
        RouterRoutingPacket *newRoutingPacket 
            = new RouterRoutingPacket(NULL, NULL, *it, this->routingTable_p);
        newRoutingPacket->setPreviousNode(this);
        (*it)->handlePacket(newRoutingPacket);
    }
    std::cout << "Router " << nodeId << " finished broadcasting routing table"
        << " at time " << SYSTEM_CONTROLLER->getCurrentTime() << "\n";
}    

Link* Router::getNextLink(Node *destination) {
	return this->routingTable_p->nextLink(destination);
}

Node* Router::getNextNode(Node *destination) {
	return this->routingTable_p->nextNode(destination);
}


/*  Updates the routing table of this router based on a neighbor's table   */
bool Router::updateRoutingTable(RoutingTable *t, Link *l) {
    assert(t != NULL);
    assert(l != NULL);
    bool changed = false;
    for (std::map<Node*, std::pair<int, Link*> >::iterator it = t->mapping.begin();
        it != t->mapping.end(); ++it) {
        Node *r = it->first;
        // If this routing table doesn't have an entry for this node, or its distance
        // is greater than the calculated distance, then create/update the entry.
        // Prevent paths that would go back through this router.
        if ((routingTable_p->mapping.count(r) == 0 ||
            (*routingTable_p)[r].first + l->getDelay() > t->mapping[r].first)
            && t->mapping[r].second != l) {
            (*routingTable_p)[r].first = t->mapping[r].first + l->getDelay();
            (*routingTable_p)[r].second = l;
            changed = true;
        }
    }
    return changed;
}


void Router::updateSingleNode(Host *host, Link *link) {
    // The router is directly connected to this host through the
    // link. Just set the distance to this host to be the link's
    // delay.
    std::pair<int, Link*> pair = std::make_pair<int, Link*>(
            link->getDelay(), link);
    (*this->routingTable_p)[host] = pair;
}

// Prints the routing table of this router to the terminal
void Router::debugRoutingTable() {
for (std::map<Node*, std::pair<int, Link* > >::iterator it
            = this->routingTable_p->mapping.begin();
        it != this->routingTable_p->mapping.end();
        it++)
    {
        Node *node = it->first;
        int id = node->getId();
        int distance = it->second.first;
        std::cout << "The distance to Node " << id << " is " << distance
            << "\n";
    }
}
